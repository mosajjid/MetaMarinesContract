const { ethers } = require("hardhat");
const { expect } = require('chai');
const { formatEther, parseEther } = require("@ethersproject/units");
const ethUtil = require('ethereumjs-util');


let order;
let signer, message, signedMessage;
let marketplace;
const privateKey = "0x"+process.env.PRIVATE_KEY;

describe("Initiation", function () {

  it("Creating signer with a private key", async function () {
    signer = new ethers.Wallet(privateKey);
  });

  it("Should show signature", async function () {
    order = [
      signer.address, '0x1F0Ad1F5280adF7AD971c0f911Cc1F7A882033C5',
      1,1,0,
      '0x0000000000000000000000000000000000000000',   //ETH
      parseEther('1.0'),
      1639048490,[],[],123
    ];

    const sig = await getSignature(signer, ...order);
    console.log(`Signature (split)`);
    console.log(`v: ${sig[0]}`);
    console.log(`r: ${sig[1]}`);
    console.log(`s: ${sig[2]}`);
  });

});



/*
 * Convert order data to typed data for signing
 */
const toTypedOrder = (
    userAddress, tokenAddress, id, quantity, listingType, paymentTokenAddress, valueToPay, deadline, bundleTokens, bundleTokensQuantity, salt
) => {
  const domain = {
    chainId: 4,
    name: 'Decrypt Marketplace',
    verifyingContract: marketplace.address,
    version: '1',
  };

  const types = {
    Order: [
      { name: 'user', type: 'address' },
      { name: 'tokenAddress', type: 'address' },
      { name: 'tokenId', type: 'uint256' },
      { name: 'quantity', type: 'uint256' },
      { name: 'listingType', type: 'uint256' },
      { name: 'paymentToken', type: 'address' },
      { name: 'value', type: 'uint256' },
      { name: 'deadline', type: 'uint256' },
      { name: 'bundleTokens', type: 'bytes32' },
      { name: 'salt', type: 'uint256' },
    ],
  };

  //hashing array of tokens IDs + array of tokens quantities
  //same as keccak256(abi.encodePacked( <array> ))
  let bundleTokensHash;
  if(bundleTokens.length === 0){
    bundleTokensHash = '0x0000000000000000000000000000000000000000000000000000000000000000';
  }
  else{
    const typesArray = new Array(bundleTokens.length).fill('uint256');
    const indexHash = ethers.utils.solidityKeccak256(typesArray,bundleTokens);
    const arrayHash = ethers.utils.solidityKeccak256(typesArray,bundleTokensQuantity);
    bundleTokensHash = ethers.utils.solidityKeccak256(['bytes32','bytes32'],[indexHash,arrayHash]);
  }
  console.log(`bundleTokensHash = ${bundleTokensHash}`);

  const value = {
    user: userAddress,
    tokenAddress: tokenAddress,
    tokenId: id,
    quantity: quantity,
    listingType: listingType,
    paymentToken: paymentTokenAddress,
    value: valueToPay,
    deadline: deadline,
    bundleTokens: bundleTokensHash,
    salt: salt,
  };

  return { domain, types, value };
}


/*
 * Returns split signature, generated by signing typed data by signer
 */
const getSignature = async (signer,...args) => {
  const order = toTypedOrder(...args);

  const signedTypedHash =  await signer._signTypedData(
      order.domain,
      order.types,
      order.value
  );
  const sig = ethers.utils.splitSignature(signedTypedHash);
  console.log(`Signature: ${signedTypedHash}`);

  return [sig.v, sig.r, sig.s];
}